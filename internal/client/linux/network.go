package linux

import (
	"fmt"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"cyber-range-config/internal/config"
)

// NetworkMethod represents the detected network configuration method
type NetworkMethod int

const (
	NetworkMethodUnknown NetworkMethod = iota
	NetworkMethodNetworkManager
	NetworkMethodNetplan
	NetworkMethodIfupdown
)

// ConfigureNetwork applies network configuration using the detected method
func ConfigureNetwork(cfg config.NetworkConfig) error {
	method := detectNetworkMethod()

	switch method {
	case NetworkMethodNetworkManager:
		return configureNetworkManager(cfg)
	case NetworkMethodNetplan:
		return configureNetplan(cfg)
	case NetworkMethodIfupdown:
		return configureIfupdown(cfg)
	default:
		return fmt.Errorf("no supported network configuration method found")
	}
}

// detectNetworkMethod determines which network configuration system is in use
func detectNetworkMethod() NetworkMethod {
	// Check for NetworkManager first (most common on modern distros)
	if _, err := exec.LookPath("nmcli"); err == nil {
		// Verify NetworkManager is actually running
		cmd := exec.Command("systemctl", "is-active", "--quiet", "NetworkManager")
		if cmd.Run() == nil {
			return NetworkMethodNetworkManager
		}
	}

	// Check for Netplan (Ubuntu 18.04+)
	if _, err := os.Stat("/etc/netplan"); err == nil {
		return NetworkMethodNetplan
	}

	// Check for ifupdown (older Debian/Ubuntu)
	if _, err := os.Stat("/etc/network/interfaces"); err == nil {
		return NetworkMethodIfupdown
	}

	return NetworkMethodUnknown
}

// configureNetworkManager configures network using nmcli
func configureNetworkManager(cfg config.NetworkConfig) error {
	// Find the primary connection name
	connName, err := getNMConnectionName()
	if err != nil {
		return fmt.Errorf("failed to find NetworkManager connection: %w", err)
	}

	if cfg.DHCP {
		// Set to DHCP
		cmd := exec.Command("nmcli", "connection", "modify", connName,
			"ipv4.method", "auto",
			"ipv4.addresses", "",
			"ipv4.gateway", "",
			"ipv4.dns", "")
		if output, err := cmd.CombinedOutput(); err != nil {
			return fmt.Errorf("nmcli modify failed: %s - %w", string(output), err)
		}
	} else {
		// Parse CIDR address
		ip, ipNet, err := net.ParseCIDR(cfg.Address)
		if err != nil {
			return fmt.Errorf("invalid address format: %w", err)
		}

		// Get prefix length
		ones, _ := ipNet.Mask.Size()
		address := fmt.Sprintf("%s/%d", ip.String(), ones)

		// Build nmcli command for static IP
		args := []string{"connection", "modify", connName,
			"ipv4.method", "manual",
			"ipv4.addresses", address,
		}

		if cfg.Gateway != "" {
			args = append(args, "ipv4.gateway", cfg.Gateway)
		}

		if len(cfg.DNS) > 0 {
			args = append(args, "ipv4.dns", strings.Join(cfg.DNS, ","))
		}

		cmd := exec.Command("nmcli", args...)
		if output, err := cmd.CombinedOutput(); err != nil {
			return fmt.Errorf("nmcli modify failed: %s - %w", string(output), err)
		}
	}

	// Apply the changes by reactivating the connection
	cmd := exec.Command("nmcli", "connection", "up", connName)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("nmcli connection up failed: %s - %w", string(output), err)
	}

	return nil
}

// getNMConnectionName finds the primary NetworkManager connection name
func getNMConnectionName() (string, error) {
	// List active connections
	cmd := exec.Command("nmcli", "-t", "-f", "NAME,TYPE", "connection", "show", "--active")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("failed to list connections: %w", err)
	}

	// Find first ethernet connection
	lines := strings.Split(strings.TrimSpace(string(output)), "\n")
	for _, line := range lines {
		parts := strings.Split(line, ":")
		if len(parts) >= 2 && strings.Contains(parts[1], "ethernet") {
			return parts[0], nil
		}
	}

	// Fallback: return first connection
	if len(lines) > 0 && lines[0] != "" {
		parts := strings.Split(lines[0], ":")
		if len(parts) >= 1 {
			return parts[0], nil
		}
	}

	return "", fmt.Errorf("no active network connection found")
}

// configureNetplan configures network using Netplan (Ubuntu 18.04+)
func configureNetplan(cfg config.NetworkConfig) error {
	// Find primary interface
	ifaceName, err := getPrimaryInterface()
	if err != nil {
		return fmt.Errorf("failed to find primary interface: %w", err)
	}

	var content string
	if cfg.DHCP {
		content = fmt.Sprintf(`# Generated by Cyber Range Configuration Client
network:
  version: 2
  ethernets:
    %s:
      dhcp4: true
`, ifaceName)
	} else {
		// Parse CIDR to validate
		_, _, err := net.ParseCIDR(cfg.Address)
		if err != nil {
			return fmt.Errorf("invalid address format: %w", err)
		}

		content = fmt.Sprintf(`# Generated by Cyber Range Configuration Client
network:
  version: 2
  ethernets:
    %s:
      dhcp4: false
      addresses:
        - %s
`, ifaceName, cfg.Address)

		if cfg.Gateway != "" {
			content += fmt.Sprintf("      routes:\n        - to: default\n          via: %s\n", cfg.Gateway)
		}

		if len(cfg.DNS) > 0 {
			content += "      nameservers:\n        addresses:\n"
			for _, dns := range cfg.DNS {
				content += fmt.Sprintf("          - %s\n", dns)
			}
		}
	}

	// Write netplan config
	configPath := "/etc/netplan/99-cyber-range.yaml"
	if err := os.WriteFile(configPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write netplan config: %w", err)
	}

	// Apply netplan
	cmd := exec.Command("netplan", "apply")
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("netplan apply failed: %s - %w", string(output), err)
	}

	return nil
}

// configureIfupdown configures network using /etc/network/interfaces (older Debian)
func configureIfupdown(cfg config.NetworkConfig) error {
	// Find primary interface
	ifaceName, err := getPrimaryInterface()
	if err != nil {
		return fmt.Errorf("failed to find primary interface: %w", err)
	}

	var content string
	if cfg.DHCP {
		content = fmt.Sprintf(`# Generated by Cyber Range Configuration Client
auto %s
iface %s inet dhcp
`, ifaceName, ifaceName)
	} else {
		// Parse CIDR address
		ip, ipNet, err := net.ParseCIDR(cfg.Address)
		if err != nil {
			return fmt.Errorf("invalid address format: %w", err)
		}

		// Convert netmask to dotted decimal
		mask := net.IP(ipNet.Mask).String()

		content = fmt.Sprintf(`# Generated by Cyber Range Configuration Client
auto %s
iface %s inet static
    address %s
    netmask %s
`, ifaceName, ifaceName, ip.String(), mask)

		if cfg.Gateway != "" {
			content += fmt.Sprintf("    gateway %s\n", cfg.Gateway)
		}

		if len(cfg.DNS) > 0 {
			content += fmt.Sprintf("    dns-nameservers %s\n", strings.Join(cfg.DNS, " "))
		}
	}

	// Ensure interfaces.d directory exists
	interfacesDDir := "/etc/network/interfaces.d"
	if err := os.MkdirAll(interfacesDDir, 0755); err != nil {
		return fmt.Errorf("failed to create interfaces.d: %w", err)
	}

	// Write config file
	configPath := filepath.Join(interfacesDDir, "cyber-range")
	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write interfaces config: %w", err)
	}

	// Restart networking
	// Try systemctl first, fall back to ifdown/ifup
	cmd := exec.Command("systemctl", "restart", "networking")
	if err := cmd.Run(); err != nil {
		// Fallback: ifdown/ifup
		exec.Command("ifdown", ifaceName).Run()
		cmd = exec.Command("ifup", ifaceName)
		if output, err := cmd.CombinedOutput(); err != nil {
			return fmt.Errorf("failed to bring up interface: %s - %w", string(output), err)
		}
	}

	return nil
}

// getPrimaryInterface returns the name of the primary network interface
func getPrimaryInterface() (string, error) {
	interfaces, err := net.Interfaces()
	if err != nil {
		return "", err
	}

	for _, iface := range interfaces {
		// Skip loopback
		if iface.Flags&net.FlagLoopback != 0 {
			continue
		}
		// Skip interfaces without MAC
		if len(iface.HardwareAddr) == 0 {
			continue
		}
		// Skip down interfaces
		if iface.Flags&net.FlagUp == 0 {
			continue
		}

		// Prefer eth* or en* interfaces
		name := iface.Name
		if strings.HasPrefix(name, "eth") || strings.HasPrefix(name, "en") {
			return name, nil
		}
	}

	// Fallback: first non-loopback interface with MAC
	for _, iface := range interfaces {
		if iface.Flags&net.FlagLoopback != 0 {
			continue
		}
		if len(iface.HardwareAddr) == 0 {
			continue
		}
		return iface.Name, nil
	}

	return "", fmt.Errorf("no suitable network interface found")
}
